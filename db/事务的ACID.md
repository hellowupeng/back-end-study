# 事务的ACID
复习（1）

ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。

数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转账，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。

- 原子性（Atomicity）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- 一致性（Consistency）：在事务开始之前和事务结束之后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（Repeatable read）和串行化（Serializable）。
- 持久性（Durability）：事务处理结束后，对数据的修改是永久的，即便系统故障也不会丢失。

## 如何保证原子性

## 如何保证一致性

## 如何保证隔离性

### 并发控制

并发控制机制保证在满足限制数据访问的前提下尽可能高的性能。

#### 并发控制机制

##### 悲观并发控制

读写锁

为了最大化数据库事务的并发能力，数据库中的锁被设计为两种模式，分别是共享锁和互斥锁。当一个事务获得共享锁之后，它只可以进行读操作，所以共享锁也叫读锁；而当一个事务获得一行数据的互斥锁时，就可以对该行数据进行读和写操作，所以互斥锁也叫写锁。

InnoDB存储引擎实现了两种标准的行级锁：

共享锁（S Lock），允许事务读一行数据。

排它锁（X Lock），允许事务删除或更新一行数据。

共享锁和互斥锁除了限制事务能够执行的读写操作之外，它们之间还有『共享』和『互斥』的关系，也就是多个事务可以同时获得某一行数据的共享锁，但是互斥锁与共享锁和其他的互斥锁并不兼容，我们可以很自然地理解这么设计的原因：多个事务同时写入同一数据难免会发生各种诡异的问题。

锁的算法

InnoDB存储引擎有3种行锁的算法：

Record Lock：单个行记录上的锁

Gap Lock：间隙锁，锁定一个范围，但不包含记录本身

Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身

##### 乐观并发控制

乐观并发控制也叫乐观锁，但是它并不是真正的锁，它只是一种并发控制的思想。

基于时间戳的协议

基于验证的协议

##### 多版本并发控制

InnoDB通过多版本控制的方式实现了一致性非锁定读。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放，而会去读取行的一个快照数据。

在这种大前提下，数据库系统引入了另一种并发控制机制 -*多版本并发控制*（Multiversion Concurrency Control），每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回；在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。

### 隔离级别

“事务隔离等级”用来控制锁的程度，高等级的隔离等级（如可序列化）会增加对系统的锁定开销，以及增加死锁发生的几率，隔离级别的降低也可能会造成难以发现的代码bug。

#### 可串行化

最高的隔离级别。

在基于锁机制并发控制的DBMS实现可串行化，要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在SELECT的查询中使用一个“WHERE”子句来描述范围时应该获得一个“范围锁”（range-locks）。这种机制可以避免“幻影读”（phantom reads）现象。

当采用不基于锁的并发控制时不用获取锁。但当系统检测到几个并发事务有“写冲突”时，只有一个允许提交的。

#### 可重复读

在可重复读（Repeatable reads）隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的读锁（read locks）和写锁（write locks）一直保持到事务结束，但不要求范围锁，因此可能会发生“幻影读”。

#### 提交读

在提交读（read committed）级别中，基于锁机制并发控制的DBMS需要对选定对象的写锁一直保持到事务结束，但是读锁在SELECT操作完成后马上释放，因此不可重复读现象可能会发生，也不要求“范围锁”。

#### 未提交读

未提交读（read uncommitted）是最低的隔离级别。允许“脏读”（dirty reads），事务可以看到其他事务“尚未提交”的修改。

### 读现象举例

#### 脏读

当一个事务允许读取另外一个事务修改但未提交的数据时，就可能发生脏读。

#### 不可重复读

在一次事务中，当一行数据获取两遍得到不同的结果表示发生了“不可重复读”。

在基于锁的并发控制中“不可重复读”现象发生在当执行SELECT操作时没有获得读锁或者SELECT操作执行完后马上释放了读锁；多版本并发控制中当没有要求一个提交冲突的事务回滚也会发生“不可重复读”现象。

#### 幻影读

在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。这种现象称为“幻影读”。

当事务没有获取范围锁的情况下执行SELECT...WHERE操作可能会发生“幻影读”。

## 如何保证持久性

## 死锁

死锁在多线程编程中是经常遇到的事情，一旦涉及多个线程对资源进行争夺就需要考虑当前的几个线程或者事务是否会造成死锁；解决死锁大体来看有两种办法，一种是从源头杜绝死锁的产生和出现，另一种是允许系统进入死锁的状态，但是在系统出现死锁时能够及时发现并且进行恢复。

##### 相关问题

1. 并发控制机制？
2. 死锁？
3. 范围锁？
4. 快照隔离？

##### 参考

1. [ACID](https://zh.wikipedia.org/wiki/ACID)
2. [事务隔离](https://zh.wikipedia.org/wiki/事務隔離)
3. [MySQL并发控制](https://www.jianshu.com/p/9025acd9b094)
