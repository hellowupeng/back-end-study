# java锁

## 一、公平锁、非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁。

非公平锁是指多个线程获取锁的顺序不是按照申请锁的顺序，有可能后申请锁的线程比先申请锁的线程优先获取锁。有可能会造成优先级反转或者饥饿现象。

ReentrantLock可以通过构造函数指定锁是否为公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

Synchronized是一种费公平锁。由于其并不像ReentrantLock是通过AQS（AbstractQueueSynchronizer）来实现线程调度，所以并没有任何办法能使其变成公平锁。

## 二、可重入锁

可重入锁又名递归锁，是指当前持有该锁的线程能够多次获取该锁，无须等待。

可重入锁的一个好处是可一定程度避免死锁。

ReentrantLock、Synchronized是可重入锁。

## 三、独享锁、共享锁

独享锁是指该锁一次只能被一个线程所持有。

共享锁是指该锁可被多个线程所持有。

ReentrantLock是独享锁。

Lock的另一个实现类ReadWriteLock，其读锁是共享锁，写锁是独享锁。

读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程是互斥的。

独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法（什么方法？）来实现独享或者共享。

Synchronized是独享锁。

## 四、互斥锁、读写锁

独享锁、共享锁是一种广义的说法，互斥锁、读写锁就是具体的实现。

互斥锁：ReentrantLock

读写锁：ReadWriteLock

## 五、乐观锁、悲观锁

悲观锁假定更新很可能冲突，所以先获取锁，得到锁后才更新。悲观锁代表一种阻塞式算法，得不到锁的时候，进入锁等待队列，等待其他线程唤醒，有上下文切换开销。

乐观锁假定冲突比较少，但使用CAS（Compare And Swap）自旋（While循环）更新，也就是进行冲突检测，如果确实冲突了，那也没关系，继续尝试就好了。乐观锁的更新逻辑是非阻塞式的，更新冲突的时候，他就重试，不会阻塞，不会有上下文切换开销。对于大部分比较简单的操作，无论是在低并发还是在高并发情况下，这种乐观非阻塞方式的性能都远高于悲观阻塞式方式。

悲观锁：Synchronized

乐观锁：原子变量

## 六、分段锁

分段锁是一种锁的设计，并不是具体的一种锁，Java 8 之前的ConcurrentHashMap，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

ConcurrentHashMap中的分段锁称为Segment，类似于HashMap（JDK7与JDK8）的结构，即内部拥有一个Node数组，数组中的每个元素又是一个链表（链表表头）；同时又是一个ReentrantLock（Segment继承了ReentrantLock）。

put元素的时候，不是对整个HashMap进行加锁，是先通过计算key的hash知道它要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行插入。

但是在统计size时，需要获取所有分段锁才能统计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

## 七、偏向锁、轻量级锁、重量级锁

这三种锁是指锁的状态，并且是针对Synchronized。

Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价（开销）。

轻量级锁是指锁是偏向锁时，被另一个线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

重量级锁是指当锁为轻量级锁时，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

## 八、自旋锁

自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。



##### 相关问题

1 Synchronized实现原理、源码分析？

2 ReentrantLock实现原理、源码分析？

3 ReadWriteLock实现原理、源码分析？

4 自旋锁实现原理？